# Kotlin ООП - 1

## Задача 1.

    Напишите программу на Kotlin, использующую объектно-ориентированный подход,
    которая создает базовый абстрактный класс Shape и производные классы Circle,
    Rectangle и Triangle. Реализуйте соответствующие методы в каждом классе и
    продемонстрируйте полиморфизм.

    Объяснение:
    В приведенном выше упражнении -
    Класс "Shape" объявляется в качестве абстрактного класса с двумя
    абстрактными методами: "area()" и "perimeter()". Классы Circle, Rectangle и
    Triangle наследуются от класса "Shape" и предоставляют собственные
    реализации этих методов.
    В функции "main()" создаются экземпляры Circle, Rectangle и Triangle, которые
    заносятся в список. С помощью цикла программа демонстрирует
    полиморфизм, вызывая методы area() и perimeter() на каждом объекте фигуры.
    Это динамически вызывает соответствующую реализацию на основе
    фактического типа объекта.
    Вывод программы будет отображать площадь и периметр каждой фигуры.

## Задача 2

    Напишите программу на Kotlin, использующую объектно-ориентированный подход,
    которая реализует паттерн Singleton для класса Logger, чтобы предоставить
    функциональность логирования во всем приложении.

    Объяснение:
    В приведенном выше упражнении -
    Класс "Logger" имеет закрытый конструктор, чтобы предотвратить прямое
    создание экземпляра. Класс также имеет метод log() для имитации
    функциональности логирования.
    Kotlin ООП - 1 2
    Внутри класса Logger есть объект-компаньон, который хранит ссылку на
    единственный экземпляр класса Logger. Метод getInstance() создает и
    возвращает экземпляр. Он следует подходу "двойной проверки блокировки"
    для обеспечения потоко-безопасности.
    В функции "main()" мы демонстрируем паттерн Singleton, создав два
    экземпляра Logger с помощью getInstance(). Оба экземпляра идентичны,
    потому что класс Logger гарантирует создание только одного экземпляра.
    Затем вызывается метод log() на обоих экземплярах для имитации
    логирования.
    Наконец, мы сравниваем ссылки logger1 и logger2 с помощью оператора ===,
    который возвращает true, так как они ссылаются на один и тот же объект.

```class Logger private constructor() {
        init {}
        fun log (...){}
        companion object {
            //ссылка на объект
            fun getInstance() : Logger {
            //проверки
            }
        }
    }
```

## Задача 3

    Напишите программу на Kotlin, использующую объектно-ориентированный подход,
    которая создает изолированный класс Result с подклассами Success и Error для
    представления результата операции. Используйте pattern matching для обработки
    различных типов результатов.

    Объяснение:
    В приведенном выше упражнении -
    Вначале у нас есть изолированный класс "Result" с двумя подклассами
    Success и Error. Изолированный класс ограничивает возможные подклассы
    только теми, которые определены в том же файле.
    Kotlin ООП - 1 3
    Класс "Success" содержит данные об успешной операции, а класс "Error"
    содержит сообщение об ошибке в случае неудачной операции.
    Функция "processResult()" принимает параметр типа Result и использует pattern
    matching (выражение when) для обработки различных типов результатов. Если
    результат имеет тип Result.Success, извлекаются данные и выводится
    сообщение об успехе. Если результат имеет тип Result.Error, извлекается
    сообщение об ошибке и выводится сообщение об ошибке.
    В функции "main()" мы создаем экземпляры Result.Success и Result.Error,
    которые принимают в себя строки сообщений об успехе или неудаче, и
    передаем их в функцию processResult() для обработки различных типов
    результатов с использованием pattern matching.
